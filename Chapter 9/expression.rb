# 지금까지는 루비 표현식을 사용함에 있어서 크게 신경을 쓰지 않았다. 어쨌든 a = b + c라는 문장은 매우 관례적인 것이기 때문이다. 따라서 이 장의 내용을 전혀 읽지 않고도 루비 코드들을 만들어 낼 수 있다.
# 하지만 그렇게 하면 별로 재미가 없어 보인다. ;-)
# 루비가 다른 언어들과 다른 특징 중 하나는 값을 반환할 수 있어 보이는 모든 곳에서 값을 반환한다는 것이다. 따라서 거의 모든 것이 표현식이 된다. 이것이 실제로 의미하는 바는 무엇일까?
# 이러한 특징을 통해 구문을 연속해서 쓸 수 있다는(chain statements) 점은 쉽게 유추할 수 있다.

a = b = c = 0 # => 0
[3, 1, 7, 0].sort.reverse # => [7, 3, 1, 0]

# C나 자바에서의 일반적인 구문이 루비에서는 표현식이다. 예를 들어 if와 case 구문은 둘 다 마지막에 평가된 표현식의 값을 반환한다.

song_type = if song.mp3_type == MP3::Jazz
              if song.written < Date.new(1935, 1, 1)
                Song::TradJazz
              else
                Song::Jazz
              end
            else
              Song::Other
            end

rating = case votes_cast
         when 0...10 then Rating::SkipThisOne
         when 10...50 then Rating::CouldDoBetter
         else Rating::Rave
         end

# 루비는 기본적인 연산자(+, -, *, / 등)와 함께 몇 가지 놀랄 만한 기능을 제공한다.
# 루비의 많은 연산자가 실제로는 메서드 호출로 구현되어 있다. 예를 들어 a * b + c라고 입력하면 실제로 a가 참조하는 객체에게 b를 매개 변수로 하여, '*' 메서드를 실행하라고 요청하는 것이다. 그리고 그 계산 결과로 반환된 객체에게 c를 매개 변수로 하여 '+' 메서드를 실행하라고 요청한다. 이는 다음과 같으며 완전히 정상적인 루비 표현식이다.

a, b, c = 1, 2, 3
a * b + c # => 5
(a.*(b)).+(c) # => 5

# 루비에서 모든 것은 객체이고 인스턴스 메서드를 재정의하는 것도 가능하기 때문에 기본적으로 정의된 연산 결과가 마음에 들지 않는다면 기본 연산을 재정의할 수도 있다.

class Fixnum
  alias old_plus + # 기존의 '+' 연산자에 'old_plus'라는 별칭을 붙여준다.
    def +(other) # Fixnum 클래스의 + 연산자를 재정의한다. 별로 좋은 생각은 아니다!
    old_plus(other).succ
  end
end

1 + 2 # => 4
a = 3
a += 4 # => 8
a + a + a # => 26

# 한층 더 유용한 사실은 우리가 작성한 클래스를 마치 내장 객체인 것처럼 연산자 표현식의 일부로 쓸 수 있다는 것이다. 예를 들어 왼쪽 시프트 연산자인 <<는 수신자 끝에 요소를 더한다는 의미로 많이 사용된다. 배열에서는 다음과 같이 사용한다.

a = [1, 2, 3]
a << 4 # => [1, 2, 3, 4]

# 이 연산자를 자신이 정의한 클래스에서 사용할 수도 있다.

class ScoreKeeper
  def initialize
    @total_score = @count = 0
  end
  def <<(score)
    @total_score += score
    @count += 1
    self
  end
  def average
    fail "No scores" if @count.zero?
    Float(@total_score) / @count
  end
end

scores = ScoreKeeper.new
scores << 10 << 20 << 40
puts "Average = #{scores.average}"

# 이 코드에는 약간 와 닿지 않는 부분이 있을 것이다. 그것은 << 메서드가 명시적으로 self를 반환한다는 점이다. 이렇게 한 이유는 scores << 10 << 20 << 40 같이 연쇄적으로 이 메서드를 사용할 수 있도록 하기 위해서다. << 연산자는 scores 객체 자체를 반환하기 때문에 이 객체에 다시 << 연산자를 사용해서 새로운 점수를 추가할 수 있다.
# +, *, <<와 같이 용도가 명확한 연산자뿐 아니라 대괄호를 사용한 인덱스 구현도 메서드 호출을 통해 구현되어 있다. 다음과 같은 코드가 있다.

some_obj[1, 2, 3]

# 앞의 표현식은 some_obj 객체에 [] 이름을 가진 메서드를 호출하면서 세 개의 매개 변수를 넘기는 것과 같다. 다음과 같이 메서드를 정의할 수 있다.

class SomeClass
  def [](p1, p2, p3)
    # ...
  end
end

# 마찬가지로 요소 대입은 []= 메서드를 통해 정의된다. 이 메서드는 인덱스로 넘겨진 맨 마지막 매개 변수를 값으로 하고 앞의 나머지 매개 변수들을 인덱스로 사용한다.

class SomeClass
  def []=(*params)
    value = params.pop
    puts "Indexed with #{params.join(', ')}"
    puts "value = #{value.inspect}"
  end
end

s = SomeClass.new
s[1] = 2
s['cat', 'dog'] = 'enemies'

# 알기 쉬운 연산자 표현식과 메서드 호출, (아마도) 조금은 난해할 수 있는 구문 표현식(if나 case처럼)에 대해 살펴보았다. 이외에도 루비에는 표현식에 사용할 수 있는 것이 몇 가지 더 있다.

# 문자열을 역따옴표(backquotes나 backticks라고도 표현한다)로 둘러싸거나, %x{...} 같은 구분자 형식을 사용하면, 이것은 기본적으로 사용 중인 운영 체제에 의해 커맨드로 실행된다. 결괏값은 해당하는 명령어의 표준 출력이다. 줄 바꿈이 잘리지 않고 그대로 남아 있기 때문에, 얻어지는 문자열 값 끝 부분에 리턴이나 줄 바꿈이 포함되어 있을지도 모른다.

`date`
`ls`.split[34]
%x{echo "hello there"}

# 명령어 문자열에서도 표현식 확장과 일반적인 이스케이프 문자열을 모두 사용할 수 있다.

for i in 0..3
  status = `dbmanager status id=#{i}`
  # ...
end

# 커맨드의 종료 상태값은 $? 변수를 통해 확인할 수 있다.

# 명령어 출력 표현식을 설명할 때, 역따옴표로 문자열을 둘러싸면 이 문자열이 갖는 의미는 '기본적으로' 운영 체제에서 명령어를 실행하라는 의미라고 이야기했다. 실제로는 문자열을 Object#`(역따옴표 한 개) 메서드에 매개 변수로 넘기는 것이다. 원한다면 이를 재정의할 수도 있다. 다음 예제에서는 $?를 사용한다.
# 이 변수에는 마지막으로 실행한 외부 프로세스의 종료값이 담겨 있다.

alias old_backquote `
def `(cmd)
  result = old_backquote(cmd)
  if $? != 0
    puts "*** Command #{cmd} failed: status = #{$?.exitstatus}"
  end
  result
end

print `ls -l /etc/passwd`
print `ls -l /etc/wibble`

# 대입문은 좌변값(lvalue)에 위치한 변수나 속성이 우변값(rvalue)을 참조하게 한다. 그리고 그 값을 대입식의 결괏값으로 반환한다. 이 말은 대입문도 연결해서 쓸 수 있다는 의미다. 그리고 생각하지 못한 곳에서 대입이 이루어질 수도 있다는 뜻이기도 하다.

a = b = 1 + 2 + 3
a # => 6
b # => 6
a = (b = 1 + 2) + 3
a # => 6
b # => 3

# 루비에서 대입은 두 가지 형식으로 이루어진다. 첫째는 변수나 상수에 객체 참조(object reference)를 대입하는 것이다. 이러한 형식은 언어 자체에 내장되어 있다.

instrument = "piano"
MIDDLE_A = 440

# 두 번째 형식은 왼편에 객체의 속성이나 요소값 참조를 포함하는 경우다. 이 형식은 다소 특별한데, 이는 좌변값 쪽의 메서드 호출에 의해 구현되기 때문이다. 그러므로 재정의하는 것도 가능하다.
# 우리는 이미 쓰기 가능한 객체 속성을 정의하는 법을 알고 있다. 단지 메서드 이름이 등호로 끝나게 정의해 주기만 하면 된다. 이 메서드는 매개 변수를 대입문의 우변값으로 받는다. []를 메서드를 통해 정의 가능하다는 것도 앞서 설명한 바 있다.

class ProjectList
  def initialize
    @projects = []
  end
  def projects=(list)
    @projects = list.map(&:upcase) # 이름 목록을 대문자로 저장한다.
  end
  def [](offset)
    @projects[offset]
  end
end

list = ProjectList.new
list.projects = %w{ strip sand prime sand paint sand paint rub paint }
list[3]
list[4]

# 이 예제에서 알 수 있듯이 이러한 속성 설정 메서드에는, 내부 인스턴스 변수에 대응하지 않으면 안 된다거나, 모든 속성 쓰기 메서드는 반드시 읽기 메서드에 대응해야 한다거나(또는 반대로) 하는 제약은 존재하지 않는다.
# 항상 매개 변수가 대입값이 되며 반환값은 버려진다. 다음 예제에서 속성 설정 메서드는 99를 반환하지만, 실제로 설정되는 값은 2이다.

class Test
  def val=(val)
    @val = val
    return 99
  end
end

t = Test.new
result = (t.val = 2)
result # => 2

# 프로그래밍 수업의 첫 번째 일주일 동안에 두 변수의 값을 바꾸기 위해 다음과 같이 코드를 작성해야만 했을 것이다.

# int a = 1;
# int b = 2;
# int temp;
# temp = a;
# a = b;
# b = temp;

# 루비에서는 같은 일을 훨씬 깔끔하게 수행하는 코드를 다음과 같이 작성할 수 있다.

a, b = 1, 2 # a = 1, b = 2
a, b = b, a # a = 2, b = 1

# 루비에서는 우변값(대입의 오른쪽에 오는 값)에 쉼표로 구분되는 목록을 지정할 수 있다. 대입이 이루어질 때 두 개 이상의 우변값이 있는 경우 다중 대입의 룰이 적용된다. 다음에서는 논리적으로 이를 설명할 것이다. 인터프리터 내부에서 일어나는 일들은 조금 복잡하다. 루비 1.9에서는 이러한 규칙이 달라졌기 때문에 이전 버전을 사용했다면 특히 주의해야 한다.
# 우선 모든 우변값이 왼쪽에서 오른쪽으로 평가되며 배열에 저장된다(우변값이 배열이 아닌 경우). 이 배열이 대입문에 의해 반환되는 최종 값이 된다.
# 다음으로 좌변값을 분석한다. 좌변에 요소가 하나밖에 없다면 우변의 배열은 이 요소에 배열로서 대입된다.

a = 1, 2, 3, 4 # a = [1, 2, 3, 4]
b = [1, 2, 3, 4] # b = [1, 2, 3, 4]

# 좌변에 쉼표(,)가 포함되어 있다면 우변의 값을 왼쪽에서부터 차례로 짝지어나간다. 이때 남은 요소는 버려진다.

a, b = 1, 2, 3, 4 # a = 1, b = 2
c, = 1, 2, 3, 4 # c = 1

# 루비는 우변항에서 별표(*)가 붙은 값을 발견하면, 우변값을 평가할 때 별표가 붙은 값을 전개한 다음 좌변항에 차례로 대입한다.

a, b, c, d, e = *(1..2), 3, *[4, 5] # a = 1, b = 2, c = 3, d = 4, e = 5

# 좌변항에서는 단 하나의 요소에만 별표(*)가 붙을 수 있다. 이 요소는 탐욕적이다. 최종적으로 배열이 되는 이 요소는 우변항에서 가능한 한 많은 요소를 차지한다. 따라서 *이 붙은 요소가 좌변의 맨 뒤에 온다면 앞서 짝지어지고 남은 모든 요소가 좌변항의 마지막 요소에 배열로 대입된다.

a, *b = 1, 2, 3 # a = 1, b = [2, 3]
a, *b = 1 # a = 1, b = []

# 별표가 붙은 요소가 좌변의 맨 뒤에 있지 않다면, 루비는 별표가 붙은 요소 뒤에 오는 모든 좌변값에 우변값이 대입되도록 한다. 즉 별표가 붙은 요소가 가능한 한 많은 요소를 차지하되, 다른 요소들에 최소한 하나의 값이 대입되도록 한다.

*a, b = 1, 2, 3, 4 # a = [1, 2, 3], b = 4
c, *d, e = 1, 2, 3, 4 # c = 1, d = [2, 3], e = 4
f, *g, h, i, j = 1, 2, 3, 4 # f = 1, g = [], h = 2, i = 3, j = 4

# 메서드 매개 변수와 마찬가지로 별표만 사용하면, 해당하는 부분을 버릴 수 있다.

first, *, last = 1, 2, 3, 4, 5, 6 # first = 1, last = 6

# 대입문의 좌변에 괄호로 둘러싸인 목록을 둘 수 있다. 루비는 이 목록을 중첩 대입문으로 인식한다. 이는 상위 수준의 대입을 이어가기 전에 먼저, 대응되는 우변값을 추출해서 괄호로 둘러싸인 부분에 대입한다.

a, (b, c), d = 1, 2, 3, 4 # a = 1, b = 2, c = nil, d = 3
a, (b, c), d = [1, 2, 3, 4] # a = 1, b = 2, c = nil, d = 3
a, (b, c), d = 1, [2, 3], 4 # a = 1, b = 2, c = 3, d = 4
a, (b, c), d = 1, [2, 3, 4], 5 # a = 1, b = 2, c = 3, d = 5
a, (b, *c), d = 1, [2, 3, 4], 5 # a = 1, b = 2, c = [3, 4], d = 5

# 다른 많은 언어처럼 루비에도 축약 표현이 있다. a = a + 2는 a += 2로 줄여 쓸 수 있다. 후자는 내부적으로 전자로 변환된다. 이는 사용자가 정의한 클래스에서 직접 메서드로 정의한 연산자 역시 원하는 대로 동작한다는 것을 의미한다.

class List
  def initialize(*values)
    @list = values
  end
  def +(other)
    @list.push(other)
  end
end

a = List.new(1, 2) # => [1, 2]
a += 3 # => [1, 2, 3]

# 루비에서 볼 수 없는 것 중 하나는 C와 자바의 자동 증가(++)와 자동 감소(--) 연산자다. 이것들 대신에 +=이나 -=를 사용하자.
