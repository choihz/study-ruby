# 루비는 조건적 실행에 대해 여러 가지 메커니즘을 가지고 있다. 대부분은 친숙한 방식이고, 그중 다수가 멋진 방식을 새로 소개하기도 한다. 이것들을 살펴보기에 앞서 논리 표현식에 대해 잠깐 살펴보자.

# 루비에서는 매우 간단한 참의 정의를 가지고 있다. nil과 상수 false가 아닌 모든 것은 참(true)이다. 예를 들어 "cat", 99, 0, :a_song은 모두 true이다.
# nil이 false로 다뤄지는 것은 매우 편리하다. 예를 들어 IO#gets는 파일의 다음 행을 읽어오는데 더 이상 읽어올 행이 없을 때는 nil을 반환한다. 따라서 다음과 같은 반복문을 작성할 수도 있다.

# while line = gets
#   # 처리
# end

# 하지만 C, c++, 펄 프로그래머들은 가끔씩 함정에 빠지기도 한다. 숫자 0이 false로 해석되지 않는다는 점 때문이다. 길이가 0인 문자열도 마찬가지다. 이는 고치기 어려운 습관일 수도 있다.

# 루비는 모든 표준 논리 연산자를 지원한다. and와 &&는 첫 번째 피연산자가 false이면 첫 번째 피연산자를 그대로 반환한다. 그 외에는 두 번째 피연산자를 평가하고 그 값을 반환한다(이는 단축 평가(shortcircuit evaluation)라고 알려져 있다). &&와 and의 유일한 차이는 연산자 우선순위다. and는 &&보다 우선순위가 낮다.

nil && 99 # => nil
false && 99 # => false
"cat" && 99 # => 99

# 따라서 &&와 and는 피연산자들이 모두 참일 때만 참을 반환한다.
# 마찬가지로 or와 ||는 첫 번째 피연산자가 거짓이 아니면 이를 그대로 반환한다. 첫 번째 피연산자가 거짓이면 두 번째 피연산자를 평가하고 그 결과를 반환한다.

nil || 99 # => 99
false || 99 # => 99
"cat" || 99 # => "cat"

# and와 마찬가지로 or과 ||의 차이도 우선순위에 있다. 흥미로운 점은 and와 or은 우선순위가 같은데 반해서 &&는 ||보다 우선순위가 높다는 점이다.
# ||=은 어떤 변수에 아무런 값이 없다면 대입을 하라는 의미의 관용구로 자주 사용된다.

var ||= "default value"

# 이는 거의 var = var || "default value"와 같은 표현이다. 단, 변수에 이미 대입이 이루어져 있다면 대입을 하지 않는 점이 다르다. 의사 코드로 작성하자면 var = "default value" unless var나 as var || var = "default value"가 된다.
# not과 !는 피연산자를 반전한 값을 반환한다. 즉 피연산자가 거짓이면 true를 반환하고, 참이면 false를 반환한다. 그리고 역시 not과 !도 우선순위만 다르다.

# defined? 연산자는 매개 변수(임의의 표현식이 올 수 있다)가 정의되지 않았을 때 nil을 반환하며, 그렇지 않은 경우 매개 변수에 대한 설명을 반환한다. 매개 변수가 yield 문이라면 defined?는 현재의 문맥에 블록이 결합된 경우에 한해서 'yield'라는 문자열을 반환한다.

puts defined? 1
puts defined? dummy
puts defined? printf
puts defined? String
puts defined? $_
puts defined? Math::PI
puts defined? a = 1
puts defined? 42.abs
puts defined? nil

# 논리 연산자와 더불어 루비 객체는 ==, ===, <=>, =~, eql?, equal? 등의 메서드를 통해 객체 간의 비교를 지원한다. <=>를 제외한 모든 메서드는 Object 클래스에 정의되어 있지만 적절한 의미에 맞추기 위해 하위 클래스들에서 재정의되는 일도 빈번하다. 예를 들어 Array 클래스는 ==를 재정의해서 두 배열의 원소 수가 같고, 대응되는 원소도 모두 같은 경우에만 두 객체가 같다고 판단한다.

# == 두 값이 같은지 비교한다.
# === case 구문의 when 항목이 비교할 대상과 동일한지 비교하는 데 쓰인다.
# <=> 일반적인 비교 연산자. 수신자가 매개 변수보다 작으면 -1, 같으면 0, 크면 1을 반환한다.
# <, <=, >=, > 작다 / 작거나 같다 / 크거나 같다 / 크다를 의미하는 비교 연산자
# =~ 정규 표현식 패턴이 매치되는지 검사한다.
# eql? 수신자와 매개 변수가 서로 같은 타입이며 같은 값을 가지는 경우 참이 된다. 1 == 1.0은 true이지만, 1.eql?(1.0)은 false다.
# equal? 수신자와 매개 변수가 같은 객체 ID를 가져야만 true이다.

# ==와 =~의 부정 연산자는 각각 !=와 !~이다. 이러한 연산자들이 불리면 루비는 일단 메서드가 정의되어 있는지 찾아보고, 찾으면 이를 사용한다. 찾지 못하면 각각 ==과 =~를 반전한 결과를 사용한다.
# 다음 예제에서는 비교 연산자로 ==만이 사용된다.

class T
  def ==(other)
    puts "Comparing self == #{other}"
    other == "value"
  end
end

t = T.new
p(t == "value")
p(t != "value")

# 명시적으로 !=가 정의되면 루비는 이를 사용한다.

class T
  def ==(other)
    puts "Comparing self == #{other}"
    other == "value"
  end
  def !=(other)
    puts "Comparing self != #{other}"
    other != "value"
  end
end

t = T.new
p(t == "value")
p(t != "value")

# 루비의 범위 또한 논리식으로 이용할 수 있다. 범위 exp1..exp2는 exp1이 참이 될 때까지 거짓으로 평가되고 exp2가 참이 될 때까지 참으로 평가된다. exp2가 true가 되면 범위는 리셋되고, 다시 같은 과정을 반복한다. 뒤에서 이에 대한 예제를 살펴볼 것이다.
# 루비 1.8 이전에는 정규 표현식도 논리식으로 사용할 수 있었다. 현재는 이렇게 사용할 수 없다. ~ 연산자를 사용해 $_에 대한 패턴 매치를 실행하는 것은 가능하지만 이 역시 이후 버전에서 사라질 것으로 보인다.
