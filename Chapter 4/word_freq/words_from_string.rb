# 문자열을 단어 단위로 나누는 메서드

def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end

# 이 메서드에서는 String 클래스에 정의된 유용한 downcase와 scan이라는 메서드를 사용한다. downcase 메서드는 문자열을 소문자로 변환한 결과를 반환하고, scan 메서드는 주어진 패턴에 매치되는 부분 문자열을 배열로 반환한다. 앞의 코드에서는 [\w']+ 패턴을 사용하고 있다. 이 패턴은 단어 문자와 작은 따옴표를 포함하는 문자열에 매치된다.

# 이 메서드를 실제로 사용해 보자. 결과가 배열이라는 점에 주목하자.

p words_from_string("But I didn't inhale, he said (emphatically)")

# 다음으로 할 일은 단어의 출현 빈도를 계산하는 일이다. 이를 위해 리스트에서 단어로 인덱스가 되는 해시 객체를 생성해야 한다. 해시의 각 요소에는 해당하는 단어가 등장한 횟수를 저장한다. 예를 들어 주어진 리스트의 일부를 읽어 들인 상태에서 the라는 단어가 나타났다면, 해시는 다음과 같이 그 정보를 저장한다.
# { ..., "the" => 1, ... }

# 단어 the가 next_word 변수에 대입되어 있다면 다음과 같이 the의 카운트를 더할 수 있다.
# counts[next_word] += 1

# 앞의 표현식을 실행하면 해시의 내용은 다음과 같아진다.
# { ..., "the" => 2, ... }
#
# 여기에는 어떤 단어를 처음 만났을 때 어떻게 처리할지에 대한 방법이 없다는 문제가 있다. 해당하는 단어를 인덱스로 가지는 해시의 값을 더하려고 시도해도, 인덱스에 해당하는 값이 없으면 프로그램은 제대로 작동하지 않는다. 이를 해결하기 위한 몇 가지 방법이 있다. 예를 들어 카운트를 더하기 전에 해당하는 인덱스가 있는지 확인하는 것도 한 가지 방법이다.

# if counts.has_key?(next_word)
#   counts[next_word] += 1
# else
#   counts[next_word] = 1
# end

# 이보다 더 좋은 방법이 있다. Hash.new(0)으로 해시를 생성하면 매개 변수 0이 해시의 기본값으로 사용된다. 해시에서 존재하지 않는 키를 검색하면 이 기본값이 반환된다. 이를 사용해 count_frequency 메서드를 다음과 같이 작성할 수 있다.

# word_freq/count_frequency.rb
