# 루비를 사용하는 동안 문자열 처리에 대부분의 시간을 보낼 것이다. 따라서 루비가 문자열을 처리하는 훌륭한 도구를 가지고 있는 것은 당연한 일이다. 앞서 살펴보았듯이 String 클래스 역시 100개가 넘는 메서드를 가진 강력한 도구다. 하지만 String에서 제공하는 기본적인 기능들로는 할 수 없는 문자열 조작도 있다. 예를 들어 두 번 이상 반복되는 문자열을 찾고 싶거나 열다섯 글자보다 긴 단어를 앞의 다섯 글자와 생략 부호로 축약하고 싶을 수도 있다. 이럴 때 바로 정규 표현식의 진가가 드러난다.

# 정규 표현식이란 문자열에 매치할 수 있는 패턴을 일컫는다. 'cat'과 같이 단순히 문자들을 늘어놓은 단순한 패턴부터 프로토콜 식별자로 시작해 리터럴 슬래시가 이어지고 그 이후로 뭔가를 더 붙이는 것 같은 복잡한 패턴도 매치할 수 있다. 이렇게 들으면 매우 좋게 느껴진다. 하지만 정규 표현식을 활용하기 시작하면 정규 표현식이 실제로 얼마나 강력한지 몸소 깨닫게 될 것이다.

# - 문자열 패턴에 매치하는지 테스트한다.
# - 패턴의 전부나 일부에 매치하는 부분의 문자열을 추출한다.
# - 패턴에 매치된 부분을 변경해 문자열을 변경한다.

# 루비는 간단하고 편리하게 패턴 매치와 치환을 할 수 있는 기능을 내장하고 있다. 다음 절에서는 정규 표현식 패턴을 간단히 살펴보고 루비에서 어떻게 패턴이 매치되고 이 패턴들에 대해 어떻게 치환을 수행하는지 살펴본다. 이어지는 절에서는 패턴에 대해 더 깊게 살펴보고 루비가 이를 어떻게 지원하는지 알아본다.

# 정규 표현식을 만드는 다양한 방법이 있다. 가장 많이 사용되는 방법은 슬래시 문자 사이에 패턴을 넣는 일이다. 예를 들어 "cat"이 문자열 리터럴인 것과 마찬가지로 /cat/은 정규 표현 리터럴이다.
# /cat/은 간단하지만 가장 많이 사용되는 패턴이다. 이 패턴은 부분 문자열 cat을 포함하는 모든 문자열에 매치된다. 패턴에서는 지금 열거하는 ., |, (, ), [, ], {, }, +, \, ^, $, *, ? 문자들 외에는 모두 문자 자체를 의미한다. 몇 가지 패턴과 그 패턴에 매치되는 문자열과 매치되지 않은 문자열의 예를 열거하면 다음과 같다.

/cat/ # "dog and cat"과 "catch"에는 매치하지만 "Cat"과 "c.a.t"에는 매치하지 않는다.
/123/ # "86512312"와 "abc123"에는 매치하지만 "1.23"에는 매치하지 않는다.
/t a b/ # "hit a ball"에는 매치하지만 "table"에는 매치하지 않는다.

# 특수 문자에 매치시키고 싶다면 그 특수 문자 바로 앞에 역슬래시(\)를 사용한다. 따라서 /\*/는 하나의 *에 매치되고 /\//는 슬래시에 매치된다.
# 패턴 리터럴은 큰따옴표 리터럴과 비슷하다. 예를 들어 패턴 안에서 #{...}와 같은 문자열 보간법(string interpolation)을 사용할 수 있다.

# 루비에서는 =~ 연산자를 사용해 어떤 패턴이 어떤 문자열에 매치하는지 판별한다. 문자열이 패턴에 매치되면 =~ 연산자는 매치된 위치를 숫자로 반환한다.

/cat/ =~ "dog and cat" # => 8
/cat/ =~ "catch" # => 0
/cat/ =~ "Cat" # => nil

# 원한다면 문자열이 연산자 왼편에 와도 무방하다.
# 패턴에 매치하지 않을 때는 nil을 반환한다. 루비에서는 nil이 논릿값에서 false와 같은 의미이기 때문에 패턴 매치 결과를 조건문에서 사용할 수 있다.

str = "cat and dog"
if str =~ /cat/
  puts "There's a cat here somewhere"
end

# 다음 예제는 testfile에서 on을 포함하는 행을 모두 출력한다.

File.foreach("testfile").with_index do |line, index|
  puts "#{index}: #{line}" if line =~ /on/
end

# 패턴이 매치하지 않는다는 것을 확인하는 !~ 연산자도 있다.

File.foreach("testfile").with_index do |line, index|
  puts "#{index}: #{line}" if line !~ /on/
end

# sub 메서드는 패턴과 패턴에 해당하는 부분의 치환 문자열을 인자로 받는다. 문자열에서 패턴에 매치하는 부분이 있다면 이 부분을 치환 문자열로 치환한다.

str = "Dog and Cat"
new_str = str.sub(/Cat/, "Gerbil")
puts "Let's go to the #{new_str} for a pint."

# sub 메서드는 문자열에서 맨 처음 일치하는 부분 문자열에 대해서만 작동한다. 일치하는 모든 부분 문자열을 치환하려면 gsub 메서드를 사용해야 한다(gsub의 g는 global의 줄임말이다).

str = "Dog and Cat"
new_str1 = str.sub(/a/, "*")
new_str2 = str.gsub(/a/, "*")
puts "Using sub: #{new_str1}"
puts "Using gsub: #{new_str2}"

# sub와 gsub 메서드는 새로운 문자열을 반환한다(어떠한 치환도 일어나지 않았을 때는 단순히 원래 문자열을 복사한 새로운 문자열이 반환된다).
# 원래의 문자열 자체를 변경하고자 할 때는 sub! 메서드와 gsub! 메서드를 사용한다.

str = "now is the time"
str.sub!(/i/, "*")
str.gsub!(/t/, "T")
puts str

# sub, gsub 메서드와 달리 !가 붙으면 sub!, gsub! 메서드들은 패턴이 매치될 때만 문자열을 반환한다. 문자열이 패턴에 매치되지 않으면 nil을 반환한다. 이 말은 즉 필요에 따라 !이 붙은 메서드를 조건식에서 사용할 수 있다는 말이다.

# 루비 위에서 다른 모든 것들과 마찬가지로 정규 표현식 역시 그저 객체에 불과하다. 정확히는 Regexp의 인스턴스다. 따라서 정규 표현식을 변수에 대입하거나 메서드의 인자로 넘겨줄 수도 있다.

str = "dog and cat"
pattern = /nd/
pattern =~ str # => 5
str =~ pattern # => 5

# 리터럴을 통한 정규 표현식 객체를 생성하는 것 이외에도 Regexp 클래스의 new 메서드나 r{...} 문법을 사용해서 정규 표현식 객체를 생성할 수 있다. %r 문법은 슬래시(/)를 포함하는 정규 표현식 객체를 만들 때 특히 유용하다.

/mm\/dd/ # => /mm\/dd/
Regexp.new("mm/dd") # => /mm\/dd/
%r{mm/dd} # => /mm\/dd/

# 정규 표현식이 매치되는 방식을 다루기 위한 몇 가지 옵션이 준비되어 있다. 리터럴을 사용해 정규 표현식 객체를 생성할 때는 리터럴 맨 뒤의 바로 앞에 한 글자나 여러 글자를 추가해 옵션을 지정할 수 있다. Regexp.new 메서드를 사용해 정규 표현식 객체를 생성한다면 생성자 두 번째 인자에 옵션을 지정할 수 있다.

# i : 대소문자 구분 옵션. 패턴 매치에서 패턴과 대상 문자열의 대소문자를 구별하지 않는다(과거에는 전역 변수 $= 값을 이용해서 대소문자 매치 옵션을 지정할 수 있었으나 현재는 지원하지 않는다).
# o : 정규 표현식 내에서 치환을 위한 평가를 단 한 번만 한다. 특정 정규 표현식 리터럴 안에 있는 어떤 #{...} 표현이라도 단 한 번만 실행되며 이후에는 이 결과가 사용된다. 이를 사용하지 않으면 리터럴을 통해 Regexp 객체를 생성할 때마다 #{...}의 내용을 평가하고 치환한다.
# m : 멀티라인 모드. 일반적으로 "."은 줄 바꿈을 제외한 모든 문자에 매치된다. /m 옵션을 사용하면 "."은 줄 바꿈을 포함한 모든 문자에 매치된다.
# x : 확장 모드. 정규 표현식이 복잡해지면 가독성도 떨어지게 마련이다. x 옵션을 사용하면 적절한 공백 문자와 줄 바꿈을 사용해 읽기 쉬운 정규 표현식을 만들 수 있다. 또한 #를 통한 주석도 지원한다.

# 이외에도 정규 표현식의 언어 인코딩을 지정하는 옵션들도 있다. 언어 인코딩 옵션을 지정하지 않고 정규 표현식 객체가 7비트 문자로만 이루어져 있다면 US-ASCII 인코딩을 사용한다. 그렇지 않으면 이는 리터럴을 포함하는 소스 코드의 기본 인코딩을 사용한다. 옵션은 다음과 같다. n: 인코딩 없음(ASCII), e: EUC, s: SJIS, u: UTF-8
