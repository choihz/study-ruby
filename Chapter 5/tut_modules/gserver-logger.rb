require 'gserver'

class LogServer < GServer

  def initialize
    super(12345)
  end

  def serve(client)
    client.puts get_end_of_log_file
  end

private

  def get_end_of_log_file
    File.open("/var/log/system.log") do |log|
      log.seek(-500, IO::SEEK_END) # 뒤에서 500문자 백업
      log.gets # 완전하지 않은 행은 무시
      log.read # 나머지를 반환
    end
  end
end

# LogServer는 GServer를 상속하고 있다. 이는 로그 서버가 GServer라는 것을 의미하며 따라서 GServer의 모든 기능을 공유하고 있다. 또한 GServer를 상속받는 새로운 클래스에서 고유의 특화된 기능을 정의할 수 있다는 의미이기도 하다.
# 먼저 이렇게 특화된 메서드는 initialize 메서드다. 여기서는 로그 서버를 12345번 TCP 포트를 사용해 실행한다. 포트 번호는 일반적으로 GServer 생성자로 넘겨받아 설정된다. 따라서 LogSever 클래스의 initialize 메서드에서는 부모 클래스인 GServer의 initialize 메서드에 포트 번호를 넘겨줘야 한다. 루비에서는 이러한 작업을 super 키워드를 통해 할 수 있다. super를 호출하면 루비는 이 메시지를 현재 클래스의 부모로 다시 보낸다. 이때 부모 클래스에서 super를 호출한 메서드와 동일한 메서드를 찾아서 실행한다. 이때 호출되는 메서드는 super에 넘겨진 값들을 매개 변수로 하여 실행된다.

# 클래스를 상속해서 자식 클래스를 정의할 때는, 이 클래스가 정상으로 동작하기 위한 초기화를 스스로 정의해야 할 필요가 있다. 바꿔 말하면 초기화가 필요한 상황이 아니라면, 상속하는 클래스의 initialize 메서드의 어딘가에서는 반드시 super 클래스를 호출해야만 한다(자식 클래스에서 특별히 initialize 메서드를 필요로 하지 않는다면 아무것도 하지 않아도 된다. 이때는 자식 클래스가 생성될 때 부모 클래스의 initialize 메서드를 실행한다).
# 따라서 initialize 메서드가 실행되고 나면, LogServer 객체는 프로토콜 레벨 처리에 대한 코드를 한 줄도 작성하지 않아도, 완전한 TCP 서버로 동작한다. 예제 마지막 부분에서는 서버를 실행하고 join을 호출해 서버가 종료되는 것을 기다린다.
# 이 서버는 외부의 클라이언트로부터 접속을 수신한다. 연결이 되면 서버 객체에서 serve 메서드가 실행된다. 앞서 살펴보았듯이 GServer 클래스의 serve 메서드는 비어 있었다. 이는 LogServer 클래스에서 재정의되었다. 루비가 실행해야 하는 메서드를 검색할 때 처음에 발견한 것이 serve 메서드이므로, GServer가 접속을 받았을 때 반드시 실행되는 것이 바로 직접 구현한 serve 메서드가 된다. 직접 구현한 코드에서는 로그 파일의 마지막 부분을 몇 줄 정도 읽어 들여 클라이언트에 출력해 준다.

# 이러한 serve 메서드 사용은 자식 클래스의 일반적인 사용법을 보여준다. 즉 부모 클래스가 자식 클래스화되는 것을 상정하고 있으며, 자식 클래스의 메서드를 호출하도록 기대하는 것이다. 이를 통해 TCP 서버로서의 처리는 모두 부모 클래스에 위임할 수 있으며, 자식 클래스에서는 실질적인 훅 메서드만을 호출해 애플리케이션에 기능을 추가할 수 있다. 이번 장의 마지막에 설명하겠지만 이러한 디자인은 일반적이지만 반드시 좋은 디자인은 아니다.
# 따라서 이를 사용하는 대신 루비 코드의 기능을 공유하는 또 다른 방식인 믹스인에 대해 알아보자. 믹스인을 다루기에 앞서 루비의 모듈과 친해질 필요가 있다.
