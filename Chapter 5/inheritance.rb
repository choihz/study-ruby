# 바로 이전 장에서 객체를 문자열로 변환할 필요가 있을 때 puts 메서드가 대상 객체의 to_s 메서드를 호출하는 것을 살펴보았다. 그리고 to_s 메서드를 명시적으로 가지지 않는 클래스를 만들어 보았다. 그럼에도 이러한 클래스의 객체들은 to_s 메서드 호출에 대해 무언가를 반환해 준다. 이것이 어떻게 가능한지 이해하려면 상속과 자식 클래스 생성, 그리고 루비에서 객체가 메시지를 받았을 때 어떤 메서드를 실행할지 결정하는 방법을 이해해야 한다.
# 상속을 사용하면 다른 클래스를 개선하거나 특수한 기능을 더한 클래스를 만들 수 있다. 이 클래스는 원래의 클래스에 대해 하위 클래스라고 불리며, 원래 클래스는 상위 클래스라고 한다. 자식 클래스와 부모 클래스라고도 부른다.
# 자식 클래스를 생성하는 기본적인 원리는 간단하다. 먼저 자식 클래스는 부모 클래스의 모든 기능을 상속한다. 자식 클래스에서는 부모 클래스의 모든 인스턴스 메서드를 사용할 수 있다.

class Parent
  def say_hello
    puts "Hello from #{self}"
  end
end

p = Parent.new
p.say_hello

# 자식 클래스 생성
class Child < Parent
end

c = Child.new
c.say_hello

# 여기서 부모 클래스는 say_hello라는 인스턴스 메서드 하나로 정의되어 있다. 여기서는 이 클래스의 인스턴스를 생성하고, 변수 p에 인스턴스의 참조를 대입했다.
# 그리고 자식 클래스를 생성하고자 Child < Parent 문법을 사용했다. < 문법은 오른쪽에 있는 클래스를 부모로 하는 새로운 클래스를 정의한다는 의미다. 더 작다는 의미를 가진 < 기호는 자식 클래스가 부모 클래스를 더 특수화했다는 것을 의미한다.
# 여기서는 Child 클래스에 아무런 메서드가 없다. 그럼에도 Child 클래스에서 인스턴스를 만들면 say_hello라는 메서드를 사용할 수 있다. 이는 Child 클래스가 Parent 클래스의 모든 메서드를 상속받았기 때문이다. say_hello 메서드는 현재 객체를 나타내는 self를 출력하도록 되어 있는데, 이 메서드가 Parent에 정의되어 있음에도 불구하고 Child 클래스의 인스턴스에서 호출했을 때는 Child라고 출력되는 것을 알 수 있다.

# superclass 메서드는 수신자(특정 클래스)의 부모 클래스를 반환한다.

class Parent
end
class Child < Parent
end
Child.superclass # => Parent

# 그런데 Parent 클래스에도 부모 클래스가 있을까?

Parent.superclass # => Object

# 클래스를 정의할 때 부모 클래스를 지정하지 않으면 루비는 자동으로 내장 클래스인 Object를 그 클래스의 부모로 삼는다. 그럼 Object의 부모를 찾아보자.

Object.superclass # => BasicObject

# BasicObject 클래스는 메타프로그래밍에 사용되는 클래스로 아무것도 없는 캔버스처럼 작동한다. BasicObject에도 부모 클래스가 있을까?

BasicObject.superclass # => "nil"

# BasicObject는 루비의 클래스 상속 구조에서 뿌리에 해당한다. 루비 애플리케이션의 어떤 객체라도 부모의 부모의 부모의 뿌리를 찾아가다 보면 결국에는 BasicObject에 이른다.
# 앞선 예제에서 루비에서 Child 클래스에 메서드가 정의되어 있지 않을 때 같은 이름을 가진 메서드를 부모 클래스에서 찾는 것을 살펴보았다. 여기서 좀 더 나아가 보면, 루비는 자기 자신에 정의되어 있지 않은 메서드를 자신의 부모 클래스에서 찾고, 여기서도 없으면 부모의 부모 클래스에서 찾고, 이렇게 부모 클래스가 더 이상 없을 때까지 메서드를 찾아나간다.
# 이를 통해 모든 루비 객체에서 to_s 메서드가 사용 가능한 원리를 알 수 있다. to_s 메서드는 Object 클래스에 정의되어 있다. Object 클래스는 BasicObject를 제외한 모든 클래스의 부모 클래스이므로 루비의 어떤 클래스의 인스턴스라도 to_s 메서드가 정의되어 있는 것이다.

class Person
  def initialize(name)
    @name = name
  end
end
p = Person.new("Michael")
puts p

# 이전 장에서 to_s 메서드를 오버라이드할 수 있는 것을 보였다.

class Person
  def initialize(name)
    @name = name
  end
  def to_s
    "Person named #{@name}"
  end
end
p = Person.new("Michael")
puts p

# puts 메서드는 인자에 대해 to_s 메서드를 호출한다. 이 예제에서 인자는 Person 객체다. Person 객체에는 to_s 메서드가 명시적으로 정의되어 있으므로 이를 호출한다. 이 클래스에 to_s 메서드가 없다면 루비는 Person의 부모 클래스인 Object에서 to_s 메서드를 찾는다.

# 자식 클래스는 표준 라이브러리나 프레임워크 클래스에 해당 애플리케이션에만 적용되는 기능을 추가할 때 주로 사용된다. 루비 온 레일스를 사용한다면 자신만의 컨트롤러 클래스들을 정의하기 위해 ActionController를 상속할 것이다. 이를 통해 자신의 컨트롤러에서 ActionController의 모든 기능을 사용할 수 있으며 추가적으로 사용자의 요청에 대응할 수 있는 고유의 핸들러를 정의할 수 있다.
# 다음은 좀 더 자기 완결적인 예제다. 루비에는 기본적으로 간단한 TCP 서버 기능이 구현된 GServer 라이브러리가 있다. GServer를 상속하는 클래스 구현을 통해 여기에 추가적인 기능을 덧붙일 수 있다. 이를 사용해 클라이언트가 소켓에 접속하는 것을 기다리다 시스템 로그 파일 마지막의 몇 줄을 반환하는 프로그램을 작성해 보자. 이 예는 실행 시간이 긴 애플리케이션에 매우 유용하다. 이러한 서버를 사용해서 애플리케이션 실행 중에 애플리케이션의 상태를 알 수 있다.

# GServer 클래스는 TCP 소켓과 소통하기 위한 모든 처리를 할 수 있다. GServer 객체를 만들 때 리슨하고자 하는 포트를 지정한다. 그리고 클라이언트가 연결되면 GServer 객체는 serve 메서드를 호출해 접속에 대해 처리한다. 다음은 GServer 클래스의 serve 메서드 구현을 나타낸다.

# def serve(io)
# end

# 코드에서 볼 수 있듯이 아무것도 하지 않는다. 새로 정의할 LogServer 클래스에서 serve 메서드를 재정의해야 한다.

# tut_modules/gserver-logger.rb
