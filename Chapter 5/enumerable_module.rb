# 루비의 컬렉션 클래스(Array, Hash 등)가 많은 기능을 지원한다는 사실은 이미 알고 있을 것이다. 이를 이용해서 컬렉션을 탐색하거나 정렬하는 등 다양한 작업을 할 수 있다. 아마도 이렇게 생각할지도 모르겠다. "어라, 그럼 내 클래스도 이런 근사한 것들을 전부 지원해 주면 좋겠군!"
# 사실 새로 작성한 클래스는 이런 잡다한 기능을 전부 지원할 수 있다. 믹스인과 Enumerable 모듈의 마법에 감사할 일이다. 이를 위해 해야 할 일은 단 한 가지, 집합의 각 원소를 차례로 반환하는 each라는 반복자를 작성하는 것 뿐이다. 그리고 Enumerable 모듈을 믹스인하면, 갑자기 이 클래스가 map, include?, find_all 같은 메서드를 지원하게 된다. 또한 그 집합의 원소들이 <=> 메서드를 통해 그것들 간의 의미 있는 순서를 정할 수 있다면 min, max, sort 같은 메서드도 얻게 될 것이다.

# Enumerable은 표준 믹스인으로 인클루드하는 클래스의 each 메서드를 사용해 다양한 메서드를 구현한다. Enumerable에 정의된 메서드로 inject 메서드가 있다. inject 메서드는 컬렉션 맨 앞의 두 개의 요소에 대해 함수나 계산을 실행하고 그 결과를 가지고 세 번째 요소에 대해 다시 같은 연산을 실행하고, 이러한 과정을 컬렉션의 모든 요소에 대해 실행한다.
# inject는 Enumerable 모듈을 통해 사용할 수 있다. 먼저 Enumerable 모듈을 인클루드하고, each 메서드를 정의하면 inject 메서드도 사용 가능해진다. 실제로 많은 내장 클래스에서 그렇게 사용하고 있다.

[1, 2, 3, 4, 5].inject(:+) # => 15
('a'..'m').inject(:+) # => "abcdefghijklm"

# Enumerable을 믹스인해서 inject 메서드를 가지는 클래스를 직접 만들어 보자.

# tut_modules/vowel_finder.rb

# 지금까지 예제에서 inject를 호출할 때 같은 패턴을 사용했음에 주목하자. 모두 합을 구하기 위해 inject 메서드를 사용했다. 숫자에 적용했을 때는 산술적인 합을 반환하고, 문자열에 적용했을 때는 그 문자열들을 이어준다. 모듈을 사용해 이 기능을 캡슐화할 수 있다.

# tut_modules/summable.rb

# C++에서 루비로 넘어온 사람들은 흔히 이렇게 질문하곤 한다 "믹스인할 때 인스턴스 변수는 어떻게 되나요? C++에서는 다중 상속 구조에서 변수가 공유되는 방법을 제어하기 위해 별짓을 다 했어요. 루비에서는 이것을 어떻게 다루나요?"
# 루비에서 인스턴스 변수가 어떻게 작동하는지 떠올려 보자. @이 앞에 붙은 변수가 처음 쓰일 때 현재 객체인 self에 인스턴스 변수를 만든다.
# 믹스인에 적용해 보면, 이 말은 클라이언트 클래스(mixee?)에 섞은 모듈이 클라이언트 객체에 인스턴스 변수를 만들고 attr_reader 등의 메서드를 이용해서 이 인스턴스 변수를 위한 접근자까지 만들어 준다는 것을 뜻한다. 예를 들면, 다음 예제의 Observable 모듈은 이를 인클루드한 모든 클래스에 @observer_list 인스턴스 변수를 추가한다.

# tut_modules/observer_impl.rb

# 그런데 이러한 행동은 위험을 동반한다. 믹스인의 인스턴스 변수는 호스트 클래스의 변수나 다른 믹스인의 변수와 충돌할 수 있다는 점이다. 다음 예제는 Observer 모듈을 사용하는데, 불행하게도 @observer_list라는 인스턴스 변수를 이미 사용하고 있다. 실행 중에 이 프로그램은 알아채기 힘든 방식으로 버그를 일으킨다.

# tut_modules/observer_impl_eg.rb

# 대부분의 경우 믹스인이 되는 모듈이 자신만의 인스턴스 데이터를 가지지는 않는다. 접근자를 사용해서 클라이언트 객체로부터 데이터를 얻어오는 것이 일반적이다. 하지만 믹스인 자체가 상태를 가지길 원하는 경우, 그 인스턴스 변수는 시스템에 있는 다른 어떠한 믹스인과도 구별되는 유일한 이름을 가져야 한다(모듈의 이름을 변수 이름에 합쳐버리면 편할 것이다). 대안으로 모듈이 루비 인스턴스 변수를 직접 쓰지 않고 현재의 객체 ID로 색인하여 인스턴스별로 다른 데이터를 저장할 수 있는 모듈 수준의 해시를 사용할 수도 있다.

module Test
  State = {}
  def state=(value)
    State[object_id] = value
  end
  def state
    State[object_id]
  end
end

class Client
  include Test
end

c1 = Client.new
c2 = Client.new
c1.state = 'cat'
c2.state = 'dog'
puts c1.state
puts c2.state

# 이 방법의 단점은 객체가 삭제되어도 그 객체에 연관된 데이터는 자동으로 삭제되지 않는다는 점이다. 일반적으로 자신의 상태를 가지는 믹스인은 믹스인이라고 할 수 없다. 이는 클래스로 작성되어야 한다.

# 사람들이 믹스인에 대해 묻는 질문 중 하나는 메서드를 어떻게 찾는가 하는 것이다. 정확히는 같은 이름의 메서드가 클래스에도 있고, 그 부모 클래스에도 있고, 클래스에 포함된 믹스인에도 있을 경우에 어떤 일이 벌어지겠느냐는 것이다.
# 답은 바로, 루비는 가장 먼저 객체의 클래스 그 자체를 찾아본 후, 클래스에 포함된 믹스인을 찾아보고, 그 후에 상위 클래스와 상위 클래스의 믹스인을 살핀다는 것이다. 클래스에 여러 개의 모듈이 믹스인되어 있다면, 마지막에 포함된 것부터 찾는다.
