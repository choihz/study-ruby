# 루비는 정수(integer), 부동소수점(floating-point), 유리수(rational), 복소수(complex number)를 지원한다. 정수의 길이는 정해지지 않는다(정수의 최대 길이는 사용하는 시스템의 메모리 크기에 의해 결정된다). 특정 범위의 정수(-2^30~2^30-1, -2^62~2^62-1)는 Fixnum 클래스의 객체로 내부적으로는 이진 형태로 저장된다. 이 범위를 넘어서는 정수는 Bignum 객체로 저장된다(현재는 작은 정수의 가변 길이 집합으로 구현되어 있다). 이런 과정은 투명하게 진행되는데, 루비가 양방향의 변환을 자동으로 해 주기 때문이다.

num = 10001
4.times do
  puts "#{num.class}: #{num}"
  num += num
end

# 정수를 표현할 때 숫자 앞부분에 적당한 부호를 붙일 수도 있고, 진법을 나타내는 특정 문자를 사용할 수도 있다(8진수는 0, 10진수는 0d(기본값), 16진수는 0x, 2진수는 0b를 사용한다). 그리고 정수 중간에 쓰인 밑줄(underscore)은 무시한다(큰 숫자에서 쉼표 위치에 밑줄을 사용하기도 한다).

puts 123456
puts 0d123456
puts 123_456
puts -543
puts 0xaabb
puts 0377
puts -0b10_1010
puts 123_456_789_123_456_789

# 소수점과 지수가 이어지는 숫자 리터럴은 운영 체제 고유의 double 타입에 상응하는 Float 객체로 변환된다. 소수점 앞뒤는 반드시 숫자여야 한다. 예를 들어 1.0e3을 1.e3이라고 쓰면 루비는 객체 1의 e3 메서드를 호출하려고 한다.
# 루비는 유리수와 복소수를 지원한다. 유리수는 두 정수의 비율이며 분수로 표현된다. 따라서 float와 달리 정확한 표현을 가진다. 복소수는 복소평면(complex plane)에 점으로 표현되며, 실수부와 가수부 두 요소로 구성된다.
# 루비는 유리수와 복소수를 나타내는 리터럴 문법을 가지고 있지 않다. 이 객체들을 생성하려면 리터럴 대신 Rational과 Complex 클래스의 생성자를 사용해야 한다(단, mathn 라이브러리를 사용하면 유리수를 좀 더 쉽게 만들 수 있다).

Rational(3, 4) * Rational(2, 3) # => (1/2)
Rational("3/4") * Rational("2/3") # => (1/2)

Complex(1, 2) * Complex(3, 4) # => (-5+10i)
Complex("1+2i") * Complex("3+4i") # => (-5+10i)

# 모든 숫자는 객체이므로 다양한 메시지를 처리할 수 있다. 따라서 c++에서는 숫자의 절댓값을 얻기 위해 abs(num)이라고 쓰지만, 루비에서는 num.abs라고 쓰면 된다.
# 루비에서는 숫자를 포함한 문자열이 자동으로 숫자 타입으로 변환되지 않는다. 예를 들어 각 줄에 숫자 두 개가 있는 다음 파일을 읽어서 각각의 합계를 구하고 싶다고 해 보자.

# 3 4
# 5 6
# 7 8

# 다음 코드는 예상대로 작동하지 않을 것이다.

some_file.each do |line|
  v1, v2 = line.split # 공백으로 행을 구분
  print v1 + v2, " "
end

# 문제는 파일에서 읽어 들인 값이 숫자가 아니라 문자열이라는 것이다. 문자열에 더하기 연산을 적용하면 두 문자열을 하나로 합친다. 이런 문제를 해결하기 위해서는 Integer 클래스를 이용해서 문자열을 숫자로 변환해야 한다.

some_file.each do |line|
  v1, v2 = line.split
  print Integer(v1) + Integer(v2), " "
end

# 대부분의 경우 숫자는 예상한 대로 작동한다. 같은 클래스의 서로 다른 숫자에 대해 특정한 연산을 수행한다면 그 계산 결과는 원래 클래스의 객체가 될 것이다(단 Fixnum과 Bignum에 대해서는 필요에 따라 변환이 일어난다). 계산의 대상이 되는 두 숫자가 서로 다른 클래스라면 좀 더 일반적인 클래스로 숫자가 변환될 것이다. 예를 들어 정수와 부동소수점을 같이 계산하면 그 결과는 부동소수점이 되고, 부동소수점과 복소수를 계산하면 그 결과는 복소수가 된다.

1 + 2 # => 3
1 + 2.0 # => 3.0
1.0 + 2 # => 3.0
1.0 + Complex(1, 2) # => (2.0+2i)
1 + Rational(2, 3) # => (5/3)
1.0 + Rational(2,3) # => 1.6666666666665

# 반환값 규칙은 나눗셈에 대해서도 마찬가지로 적용된다. 하지만 이 규칙에 따라서 정수를 정수로 나눈 값도 정수가 되므로 헷갈릴 수 있다.

1.0 / 2 # => 0.5
1 / 2.0 # => 0.5
1 / 2 # => 0

# 정수 간의 나눗셈이 분수(Rational 값)를 반환해야 한다면 mathn 라이브러리가 필요하다. 이를 통해 숫자 계산의 실행 결과가 가장 자연스러운 표현이 자동으로 선택된다. 따라서 이제 정수 간의 나눗셈은 더 이상 정수를 반환하지 않고, 대신에 분수를 반환한다.

22 / 7 # => 3
Complex::I * Complex::I # => (-1+0i)

require 'mathn'
22 / 7 # => (22/7)
Complex::I * Complex::I # => -1

# 정수는 몇 가지 유용한 반복자를 지원한다. 앞서 5.times와 같은 표현을 보인 바 있다. 이 외에 숫자와 숫자 사이를 반복하는 upto와 downto 메서드도 지원한다. Numeric 클래스는 이에 대한 더 추상적인 형태인 step을 지원하는데, 이는 전통적인 반복문과 비슷하다.

3.times { print "X " }
1.upto(5) {|i| print i, " "}
99.downto(95) {|i| print i, " "}
50.step(80, 5) {|i| print i, " "}

# 다른 반복자들과 마찬가지로 앞의 반복자들도 호출할 때 블록을 넘기지 않으면 Enumerator 객체를 반환한다.

10.downto(7).with_index {|num, index| puts "#{index}: #{num}"}
