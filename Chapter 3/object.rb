# 루비에서 다루는 모든 것은 객체다. 루비의 객체는 클래스에서 직간접적으로 생성할 수 있다. 이번 장에서는 이러한 객체를 생성하는 클래스를 만들고 다루는 법을 자세히 살펴본다.

# 객체 지향 시스템을 설계할 때 항상 제일 먼저 해야 하는 일은 다루고자 하는 대상들의 특징을 파악하는 것이다. 일반적으로 다루고자 하는 대상들이 속하는 형식(type)은 완성된 프로그램에서 클래스로 만들어진다. 그리고 각 대상은 이 클래스의 인스턴스가 된다.

# 헌책방에서 바코드 스캐너로 스캔하면 날짜, 책의 ISBN, 가격이 나온다.
# 이 문제를 푸는 데 있어 분명한 것은, 스캐너에서 읽어 들인 데이터를 나타낼 무언가가 필요하다는 것이다. 이 무언가의 각 인스턴스는 원본 데이터의 한 줄에 담긴 데이터를 가지고 있으며, 이 인스턴스들 전체를 모으면 스캔해서 수집한 데이터 전체가 된다.
# 이 클래스를 BookInStock이라고 이름 짓자(루비에선 클래스 이름은 대문자로 시작해야 하며, 메서드 이름은 소문자로 시작해야 한다).

class BookInStock
end

# 클래스의 인스턴스를 생성할 때는 new 메서드를 사용한다.

a_book = BookInStock.new
another_book = BookInStock.new

# 앞의 코드를 실행하면 BookInStock 클래스를 기반으로 하는 두 개의 서로 다른 객체가 생성된다. 하지만 아직까지 두 객체가 저장된 변수 이름이 다르다는 것 외에 두 객체를 구분할 수 있는 차이는 없다. 더 심각한 것은 이 객체들에는 분석하고자 하는 어떠한 데이터도 저장되어 있지 않다는 점이다.

# 이러한 문제를 해결하는 가장 좋은 방법은 생성자 메서드를 정의하는 일이다. 이를 통해 객체가 생성되는 시점에 생성하고자 하는 객체에 특정한 상태를 저장할 수 있다. 이러한 상태는 객체의 인스턴스 변수로 저장된다(인스턴스 변수는 @로 시작한다는 점을 잊지 말자). 루비에서 각 객체는 자신만의 인스턴스 변수들을 가지고 있으며 이를 통해 객체 고유의 상태를 저장한다.
# 앞서 정의한 BookInStock 클래스를 개선해 보자.

class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end

# 루비에서 initialize 메서드는 생성자를 의미하는 특별한 메서드다. 새로운 객체를 만들기 위해 BookInStock.new를 호출하면 루비는 초기화되지 않은 객체를 메모리에 할당하고 new의 매개 변수를 이용해 그 객체의 initialize 메서드를 호출한다. 객체의 상태를 초기화하기에 가장 적당한 곳이다.
# BookInStock 클래스의 initialize 메서드에는 두 개의 매개 변수가 필요하다. 이 매개 변수들은 메서드 안에서 지역 변수로 사용된다. 따라서 매개 변수는 지역 변수 명명 규칙을 따른다.
# 주의해야 할 점이 하나 있다. 매개 변수는 지역 변수와 같은 스코프를 가지므로 initialize 메서드가 끝나면 함께 사라져 버린다. 따라서 필요한 정보를 인스턴스 변수에 저장해야 한다. 이러한 방식이 initialize를 사용한 일반적인 초기화 방법이다. initialize 메서드가 끝나는 시점에 객체는 사용 가능한 상태여야 한다.

# 앞 예제의 Float 메서드는 인자를 받아 이 값을 부동소수점으로 변환한다. 이때 형 변환에 실패하면 예외를 발생시키며 프로그램을 종료한다. 여기서는 price를 매개 변수로 넘겨주며, price가 부동소수점으로 변환 가능한 객체라면 무엇이든 사용할 수 있다. price는 부동소수점(float)이나 정수(integer)가 될 수 있고, 부동소수점을 나타내는 문자열도 정상적으로 처리된다.

# 이제 이 클래스를 실제로 사용해 보자. 이어지는 예제에서는 서로 다른 상태로 초기화된 객체 세 개를 만든다. p 메서드는 객체의 내부 상태를 출력한다. 이를 사용해 각 매개 변수를 넘겼을 때 내부적으로 변경된 객체의 상태가 인스턴스 변수에 어떻게 저장되어 있는지 알 수 있다.

class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = price
  end
end

b1 = bookInStock.new("isbn1", 3)
p b1

b2 = bookInStock.new("isbn2", 3.14)
p b2

b3 = bookInStock.new("isbn3", "5.67")
p b3

# puts는 단순히 프로그램의 표준 출력에 문자열을 출력한다. puts에 어떤 클래스에서 생성된 객체를 인자로 넘겨주면, puts는 이를 어떻게 다뤄야 할지 모르므로 가장 간단한 방법으로 처리한다. 객체의 이름을 출력하고 콜론(:) 다음에 16진수로 된 고유 번호를 출력한다. 이 정보는 #<...> 사이에 출력된다.
# 루비에는 객체를 문자열로 나타내는 표준 메시지인 to_s가 준비되어 있다. puts에 BookInStock 객체가 넘겨지면 puts는 내부적으로 넘겨받은 객체에서 to_s를 호출하고 이 결과를 출력한다. 이제 더 나은 출력 결과를 보기 위해 to_s 메서드를 재정의하자.
#

class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
  def to_s
    "ISBN: #{@isbn}, price: #{@price}"
  end
end

# 객체에 정의된 인스턴스 변수들은 각 객체에 저장되며 이 객체에 정의되는 모든 인스턴스 메서드에서 참조 가능하다.
